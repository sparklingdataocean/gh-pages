<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Spark for Big Data Analytics.">

    <title>Multi-Layer Graph Analysis for Text-Driven Relationships Using GNN Link Prediction - Sparkling Data Ocean</title>

    <link rel="canonical" href="http://localhost:4000/2024/06/21/knowledgeGraphEmail/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Sparkling Data Ocean" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114694347-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-114694347-1');
    </script>

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Sparkling Data Ocean</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
				
                <li>
                    <a href="/about/">About</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/pageVec33.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Multi-Layer Graph Analysis for Text-Driven Relationships Using GNN Link Prediction</h1>
                    
                    <h2 class="subheading">Unlocking Insights into Complex Networks with the Enron Email Dataset and Advanced Graph Techniques</h2>
                    
                    <span class="meta">Posted by Melenar on June 21, 2024</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<p><h3> </h3>
<p></p>

Analyzing complex graphs can be quite challenging, especially when the whole is greater than the sum of its parts. To address these challenges, we dive into the Enron email dataset, using its rich information to create a strong multi-layer graph analysis framework.
<p></p>
We start by building a foundational graph layer where email addresses are the nodes and email exchanges form the edges. This layer gives us a clear picture of the communication network, showing the direct interactions between individuals within the dataset.
<p></p>

Building upon this, we introduce a second graph layer that goes deeper into the content of these communications. Here, each interaction is represented as a node in the form of triplets—comprising the sender, receiver, email subject, and body. Edges in this layer signify communication chains, illustrating how discussions and information flow within the network.
<p></p>
To extract meaningful patterns from the textual content, we transform these triplet nodes into vectors using a transformer model. This transformation captures the semantic nuances of the email content. Following this, a Graph Neural Network (GNN) Link Prediction model is applied to these vectors. The model identifies potential links within the graph based on semantic similarity and structural patterns.
<p></p>

The output vectors from the GNN Link Prediction model, which capture both the semantic content and the graph structure, help us create a third graph layer. In this layer, nodes represent pairs of emails with high cosine similarities, forming a network that highlights strong semantic connections.
<p></p>
This third graph layer is key to identifying influencers within the network, revealing individuals who play important roles in spreading information. It also gives us a better understanding of engagement dynamics, showing how interactions evolve and spread across the network.
<p></p>
By using this multi-layer approach, we provide a comprehensive framework for analyzing complex textual interactions within graph structures. This method not only offers deeper insights into network dynamics but also improves our ability to identify key influencers, ultimately enhancing our understanding of intricate communication networks.

<p></p>

<h3>Introduction</h3>
<p></p>

Graphs are powerful tools for representing complex relationships, with each level building on the previous one’s capabilities and efficiency. Think of atoms forming molecules with unique properties, molecules creating cells with essential functions, and cells building organs with specialized roles. However, as graphs become more intricate, analyzing them becomes increasingly challenging.
<p></p>
Complex system analysis can be approached both top-down and bottom-up. In this study, we introduce a bottom-up method for analyzing graph layers built on text-driven relationships. This approach captures intricate details and emergent properties from foundational elements upwards.
<p></p>

For example, imagine a bipartite graph with individuals on one side and movie narratives on the other. Relationships in this graph are defined by shared interests in particular movies. By exploring the narrative elements in recommender systems, we can uncover complex relationships that go beyond merely identifying pairs or groups of people with common movie interests.

<p></p>
Another example is influence networks in social media, where nodes represent users and directed edges signify interactions such as likes, comments, or shares. By examining the content of posts and interactions, we can uncover text-driven relationships that reveal influence patterns and topics of interest. This approach helps us understand the dynamics of influence and engagement within the social media ecosystem.

<p></p>



    In a prior study <a href="https://doi.org/10.5220/0011664400003393">
  'Rewiring Knowledge Graphs by Graph Neural Network Link Predictions'
    </a> (2023), we focused on rewiring text-based knowledge graphs through the use of GNN link prediction models, specifically targeting semantic knowledge graphs built from text documents. We utilized GNN link prediction techniques to modify these graphs, revealing hidden connections between nodes.
<p></p>
    In another study <a href="https://doi.org/10.1007/978-981-99-8324-7_2"> 'Uncovering Hidden Connections: Granular Relationship Analysis in Knowledge Graphs' </a> (2024), we also applied GNN link prediction models to semantic knowledge graphs to uncover hidden relationships within a detailed vector space. We focused on identifying 'graph connectors' that expose deeper network structures and used graph triangle analysis to delve into complex interactions.

<p></p>

The Enron email corpus provides a valuable opportunity to explore the potential of text-enhanced knowledge graphs in uncovering hidden patterns within organizational communication. By focusing on direct interactions and using transformer models for text embedding, we lay the groundwork for a knowledge graph that better captures the complexity of real-world relationships.

<p></p>
Our findings highlight the significant impact of incorporating textual data and GNN Link Prediction in knowledge graph analysis. This approach provides a more complete view of how entities interact, helping us understand complex networks better. As we continue to refine these methods, the potential for uncovering new insights in data-rich environments seems limitless, opening up exciting possibilities for future research.
<p></p>




    <h3>Key Methodologies of Our Study</h3>
<p></p>    
<h4>Architecture Pipeline</h4>
<p></p>
    Our architecture pipeline for the multi-layer graph approach begins with raw data processing and follows to link prediction model:
<p></p>
<a href="#">
        <img src="/img/archPipeline2.jpg" alt="Post Sample Image" width="1024" />
</a>
<p></p>
        <ul>
            <li>
                <strong>Raw Data:</strong> The initial dataset includes attributes such as ‘from’, ‘to’, ‘body’, and ‘time’.
            </li>
            <li>
                <strong>Initial Graph Layer:</strong> Email addresses are depicted as nodes connected by edges representing email exchanges.
            </li>
            <li>
                <strong>Transformation to Triplet Nodes:</strong> Email exchanges are converted into triplets (from, to, email body).
            </li>
            <li>
                <strong>Second-Layer Graph Construction:</strong> Triplet nodes form edges based on communication chains (to-to connections).
            </li>
            <li>
                <strong>Node Embedding:</strong> Embedding node features to vectors.
            </li>
            <li>
                <strong>GNN Link Prediction:</strong> The GNN model is applied, transforming triplet nodes into vectors.
            </li>
        </ul>
        <p>
            After GNN Link Prediction model training, we will examine structural changes in the network to uncover key influencers.
        </p>

<p></p>

<h4>Transformation Process from Initial Graph to Second-Layer Graph</h4>
<p></p>
The process begins with constructing the initial graph layer, where email addresses are depicted as nodes connected by edges representing email exchanges, as shown in the picture. Each email exchange is then converted into triplets consisting of 'from', 'to', and the email's subject and body. Subsequently, a second-layer graph is constructed where these triplet nodes form edges based on communication chains ('to-to' connections), as illustrated in the picture.
<p></p>
<a href="#">
    <img src="/img/kgArch.jpg" alt="Post Sample Image" width="978" />
</a>

<p></p>
<h4>Node Embedding</h4>
<p></p>
To translate text into vectors, we will use the 'all-MiniLM-L6-v2' transformer model from Hugging Face. This sentence-transformer model efficiently maps text into 384-dimensional vectors. This process transforms sentences into dense vectors, preserving their semantic content for machine learning applications. This embedding step is crucial, ensuring the text is suitably prepared for deep learning analyses, including GNN link prediction, by capturing the nuanced meanings in a format compatible with our algorithms.
<p></p>
<h4>Training the GNN Link Prediction Model</h4>

<p></p>

After setting up the nodes, we refine the graph with GNN Link Prediction to uncover detailed interactions. By examining the graph’s structure and node details, we reveal previously hidden connections, enhancing the graph’s depth and utility for analysis.
<p></p>
We use the GraphSAGE link prediction model, which generates node embeddings based on attributes and neighbors without retraining. Our study employs a GNN Link Prediction model from the Deep Graph Library (DGL), with two GraphSAGE layers. This approach improves node representation by combining details from nearby nodes and discovering hidden connections in the Enron email dataset.
<p></p>
The output vectors from this model can be used for further analysis, and we will showcase this in our 'Experiments' section.

<p></p>


<h3>Experiments Overview</h3>

<p></p>
<h4>Data Source</h4>

<p></p>

Our main data source is the Enron email corpus, a comprehensive collection of emails exchanged among executives of the Enron Corporation. This dataset, freely available to the public, captures a wealth of corporate communications, offering a deep dive into the intricacies of a complex organizational network. Its rich detail makes it an excellent resource for our knowledge graph analysis, shedding light on the dynamics of corporate interactions.
<p></p>
The Enron email corpus is hosted on Kaggle, providing easy access for those looking to conduct detailed analyses of the dataset. For further information or to explore the dataset yourself, visit <a href="https://www.kaggle.com/datasets/wcukierski/enron-email-dataset/data">Kaggle's Enron Email Dataset</a>.


<p></p>


<h4>Input Data Preparation</h4>
<p></p>

Our study starts with building a graph using the Enron email dataset from the year 2000, focusing on internal communications by selecting emails sent from @enron.com addresses. We aimed to analyze direct email exchanges between individuals, excluding group emails to ensure a clear and focused analysis.
<p></p>
For the graph’s nodes, we merged the 'From', 'To', 'Subject', and 'Body' fields of each email into a single text unit, as illustrated in the picture. This method ensures that each node fully represents an individual email conversation, including all its context and specifics.
<p></p>
To link these nodes in the graph, we connected emails that had either the same sender or recipient, indicating a direct line of communication between parties. This setup accurately mirrors how communication unfolded within Enron, revealing the network’s detailed structure and the rich interplay of relationships among employees.
<p></p>

<h4>Constructing Layer Graphs from Enron's 2000 Email Corpus</h4>
<p></p>
Our investigation begins by creating a knowledge graph derived from the Enron email dataset, specifically focusing on the year 2000. Our selection criteria were emails exchanged internally, identifiable through @enron.com addresses, allowing us to concentrate on direct communications between individual employees while excluding group emails for a more targeted analysis.
<p></p>
<h5>Node Creation in the Knowledge Graph</h5>
<p></p>
To form the nodes of our knowledge graph, we combined the 'From', 'To', 'Subject', and 'Body' of each email into a unified text representation. This approach ensured that each node captured the entirety of an email exchange, preserving both the context and the details of the conversation.
<p></p>

Concatenate 'From', 'To', 'Subject', and 'body' columns with '^' between

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">df</span><span class="p">[</span><span class="s">'emailText'</span><span class="p">]</span> <span class="o">=</span>
   <span class="n">df</span><span class="p">[[</span><span class="s">'From'</span><span class="p">,</span><span class="s">'To'</span><span class="p">,</span><span class="s">'Subject'</span><span class="p">,</span> <span class="s">'body'</span><span class="p">]]</span>
   <span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s">' ^ '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code></pre></figure>

        <p></p>
Combine and index 'From' and 'To' columns:
        <p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">unique_emails</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">[</span><span class="s">'From'</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">'To'</span><span class="p">]])</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="n">email_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">unique_emails</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_emails</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s">'emailIdx'</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'FromIdx'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'From'</span><span class="p">]</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">email_index</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'ToIdx'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'To'</span><span class="p">]</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">email_index</span><span class="p">)</span>
<span class="n">emailFromTo</span><span class="o">=</span><span class="n">df</span><span class="p">[[</span><span class="s">'FromIdx'</span><span class="p">,</span><span class="s">'emailTextIdx'</span><span class="p">,</span><span class="s">'emailText'</span><span class="p">,</span> <span class="s">'ToIdx'</span><span class="p">]]</span>
<span class="n">emailFromTo</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span></code></pre></figure>

        <p></p>

<a href="#">
            <img src="/img/enron1.jpg" alt="Post Sample Image" width="543" />
</a>

<p></p>

<h5>Linking Nodes in the Knowledge Graph</h5>
<p></p>        
        In establishing connections within the knowledge graph, we linked emails sharing common senders or recipients, thereby reflecting a direct communication pathway between entities. This method provided an accurate reflection of how interactions occurred within Enron, uncovering the intricate structure of the network and the dynamic web of relationships between employees.

<p></p>
        Self-join emailFromTo table to create edges:
<p></p>        

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">df</span><span class="o">=</span><span class="n">emailFromTo</span>
<span class="n">joined_df</span> <span class="o">=</span>
   <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s">'ToIdx'</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s">'FromIdx'</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s">'_left'</span><span class="p">,</span> <span class="s">'_right'</span><span class="p">))</span>
<span class="n">df2</span> <span class="o">=</span> <span class="n">joined_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s">'FromIdx_left != ToIdx_right'</span><span class="p">)</span>
<span class="n">dfLeft</span> <span class="o">=</span> <span class="n">em2text2em</span><span class="p">[[</span><span class="s">'emailText_left'</span><span class="p">,</span> <span class="s">'emailTextIdx_left'</span><span class="p">]]</span>
   <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s">'emailText_left'</span><span class="p">:</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'emailTextIdx_left'</span><span class="p">:</span> <span class="s">'idx'</span><span class="p">})</span>
<span class="n">dfRight</span> <span class="o">=</span> <span class="n">em2text2em</span><span class="p">[[</span><span class="s">'emailText_right'</span><span class="p">,</span> <span class="s">'emailTextIdx_right'</span><span class="p">]]</span>
   <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s">'emailText_right'</span><span class="p">:</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'emailTextIdx_right'</span><span class="p">:</span> <span class="s">'idx'</span><span class="p">})</span></code></pre></figure>

<p></p>
Excluded disconnected nodes and reindex:

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">dff</span><span class="o">=</span><span class="n">em2text2em</span>  
<span class="n">combined_df</span> <span class="o">=</span>
   <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dfLeft</span><span class="p">,</span> <span class="n">dfRight</span><span class="p">])</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">combined_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s">'A'</span><span class="p">)</span>
<span class="n">combined_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">combined_df</span><span class="p">[</span><span class="s">'new_index'</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">index</span>   
<span class="n">nodes</span><span class="o">=</span><span class="n">combined_df</span><span class="p">[[</span><span class="s">'new_index'</span><span class="p">,</span><span class="s">'A'</span><span class="p">]]</span>
<span class="n">nodes</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span>               </code></pre></figure>

<p></p>
<a href="#">
    <img src="/img/enron2.jpg" alt="Post Sample Image" width="543" />
</a>

<p></p>
      Reindex edges:

<p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">idx_mapping</span> <span class="o">=</span>
   <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">combined_df</span><span class="p">[</span><span class="s">'new_index'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">combined_df</span><span class="p">[</span><span class="s">'idx'</span><span class="p">])</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="n">dff</span><span class="p">[</span><span class="s">'new_idxLeft'</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfLeft</span><span class="p">[</span><span class="s">'idx'</span><span class="p">]</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">idx_mapping</span><span class="p">)</span>
<span class="n">dff</span><span class="p">[</span><span class="s">'new_idxRight'</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfRight</span><span class="p">[</span><span class="s">'idx'</span><span class="p">]</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">idx_mapping</span><span class="p">)</span>
<span class="n">edges</span><span class="o">=</span><span class="n">dff</span><span class="p">[[</span><span class="s">'new_idxLeft'</span><span class="p">,</span><span class="s">'new_idxRight'</span><span class="p">]]</span>
<span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
<span class="n">edges</span><span class="o">.</span><span class="n">tail</span><span class="p">()</span>           </code></pre></figure>

<p></p>

<a href="#">
    <img src="/img/enron3.jpg" alt="Post Sample Image" width="314" />
</a>

<p></p>

<h4>Model Training</h4>
<p></p>


For model training, we first used the 'all-MiniLM-L6-v2' transformer from Hugging Face to transform email texts into vectors. Next, we applied the GNN Link Prediction model from the DGL library, aiming to discover unseen graph connections by analyzing these vectors and the graph structure.
<p></p>
    <ul>
        <li>Total number of nodes: 9,654</li>
        <li>Total number of edges: 667,354</li>
        <li>Embedded nodes represented as a PyTorch tensor of size [9,654, 384]</li>
        <li>The output vector size for the GraphSAGE model was set to 64</li>
    </ul>
<p></p>
To evaluate the efficacy of the model, we employed the Area Under Curve (AUC) metric as a measure of accuracy. The achieved model accuracy was approximately 96.7%, demonstrating the model’s high predictive performance.
<p></p>

<h5>Code Details</h5>
<p></p>
Convert edges to DGL model:
    <p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">unpickEdges</span><span class="o">=</span><span class="n">edges</span>
<span class="n">edge_index</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">unpickEdges</span><span class="p">[[</span><span class="s">'new_idxLeft'</span><span class="p">,</span><span class="s">'new_idxRight'</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="o">=</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">g</span><span class="o">=</span><span class="n">dgl</span><span class="o">.</span><span class="n">graph</span><span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
<span class="n">g</span><span class="o">=</span><span class="n">dgl</span><span class="o">.</span><span class="n">add_self_loop</span><span class="p">(</span><span class="n">gNew</span><span class="p">)</span>
<span class="n">g</span>
<span class="n">Graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="mi">9654</span><span class="p">,</span> <span class="n">num_edges</span><span class="o">=</span><span class="mi">667354</span><span class="p">,</span>
  <span class="n">ndata_schemes</span><span class="o">=</span><span class="p">{}</span>
  <span class="n">edata_schemes</span><span class="o">=</span><span class="p">{})</span>      </code></pre></figure>

    <p></p>
Embed node feature text:

    <p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sentence_transformers</span> <span class="kn">import</span> <span class="n">SentenceTransformer</span>
<span class="n">modelST</span> <span class="o">=</span> <span class="n">SentenceTransformer</span><span class="p">(</span><span class="s">'all-MiniLM-L6-v2'</span><span class="p">)</span>
<span class="n">node_embeddings</span> <span class="o">=</span> <span class="n">modelST</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s">'A'</span><span class="p">],</span><span class="n">convert_to_tensor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">node_embeddings</span> <span class="o">=</span> <span class="n">node_embeddings</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s">'cpu'</span><span class="p">))</span>
<span class="n">g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s">'feat'</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_embeddings</span>
<span class="n">g</span>
<span class="n">Graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="mi">9654</span><span class="p">,</span> <span class="n">num_edges</span><span class="o">=</span><span class="mi">667354</span><span class="p">,</span>
  <span class="n">ndata_schemes</span><span class="o">=</span><span class="p">{</span><span class="s">'feat'</span><span class="p">:</span> <span class="n">Scheme</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">384</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)}</span>
  <span class="n">edata_schemes</span><span class="o">=</span><span class="p">{})</span>        </code></pre></figure>

    <p></p>
    In our training process, we leveraged the GraphSAGE model, following closely with examples provided in the Deep Graph Library (DGL) tutorial. This choice allowed us to utilize a well-established framework for our Graph Neural Network (GNN) Link Prediction model, ensuring a solid foundation for our analysis. Below are GNN Link Prediction model statistics:

    <p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">all_logits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="c"># forward</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">train_g</span><span class="p">,</span> <span class="n">train_g</span><span class="o">.</span><span class="n">ndata</span><span class="p">[</span><span class="s">'feat'</span><span class="p">]</span><span class="o">.</span><span class="nb">float</span><span class="p">())</span>
    <span class="n">pos_score</span> <span class="o">=</span> <span class="n">pred</span><span class="p">(</span><span class="n">train_pos_g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">neg_score</span> <span class="o">=</span> <span class="n">pred</span><span class="p">(</span><span class="n">train_neg_g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">compute_loss</span><span class="p">(</span><span class="n">pos_score</span><span class="p">,</span> <span class="n">neg_score</span><span class="p">)</span>
    <span class="c"># backward</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">e</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'In epoch {}, loss: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">loss</span><span class="p">))</span>       </code></pre></figure>

<p></p>
<a href="#">
    <img src="/img/enron4.jpg" alt="Post Sample Image" width="314" />
</a>

<p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">pos_score</span> <span class="o">=</span> <span class="n">pred</span><span class="p">(</span><span class="n">test_pos_g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">neg_score</span> <span class="o">=</span> <span class="n">pred</span><span class="p">(</span><span class="n">test_neg_g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'AUC'</span><span class="p">,</span> <span class="n">compute_auc</span><span class="p">(</span><span class="n">pos_score</span><span class="p">,</span> <span class="n">neg_score</span><span class="p">))</span>         
<span class="n">AUC</span> <span class="mf">0.9673248461572111</span></code></pre></figure>

<p></p>


<h4>Results and Further Analysis</h4>

<p></p>

The GNN Link Prediction model outputs a set of re-embedded vectors that capture nuanced relationships within the graph. These vectors are valuable for deeper analysis, including statistical evaluation, clustering, and gaining further insights into the network’s structure. In this study, we built a new graph layer based on pairs of vectors with a cosine similarity threshold of 0.95, allowing for a detailed examination of the network’s dynamics and connections.
<p></p>
This method enables us to observe which influencers within the network have become more or less central after introducing these new connections. For this analysis, we focused on betweenness centrality, which measures a node’s importance in a graph by indicating how often it acts as a bridge along the shortest path between two other nodes. In complex relationships, these metrics help identify key nodes that facilitate communication or interaction across the network, revealing shifts in centrality and influence based on the newly established connections.
<p></p>
<p></p>    
    <a href="#">
        <img src="/img/enronResult1.jpg" alt="Post Sample Image" width="567" />
    </a>
<p></p>
When we compare the betweenness centrality scores before and after applying our method, we observe shifts in network influence. Initially, graph connections were based solely on direct email interactions. After incorporating text-driven relationships, new dynamics and hidden connections were revealed. This significantly altered the network’s structure, uncovering previously unrecognized key connectors and providing a more comprehensive view of the network’s influence and interactions.


  <p></p>

<p></p>

<a href="#">
    <img src="/img/enronResult2.jpg" alt="Post Sample Image" width="567" />
</a>
<p></p>

<p></p>

<p></p>



<h5>Code Details</h5>
<p></p>
Cosine Similarities function:    
<p></p>
    
<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="kn">import</span> <span class="nn">torch</span>
    <span class="k">def</span> <span class="nf">pytorch_cos_sim</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cos_sim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cos_sim</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">a_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">a_norm</span><span class="p">,</span> <span class="n">b_norm</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    </code></pre></figure>

    <p></p>
Select pairs of vectors with cosine similarities higher than 0.95.
    <p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">cosine_scores_gnn</span> <span class="o">=</span> <span class="n">pytorch_cos_sim</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="n">pairs_gnn</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cosine_scores_gnn</span><span class="p">)):</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cosine_scores_gnn</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">cosine_scores_gnn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.95</span><span class="p">:</span>
        <span class="n">pairs_gnn</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">'idx1'</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span><span class="s">'idx2'</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span>
        <span class="s">'score'</span><span class="p">:</span> <span class="n">cosine_scores_gnn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()})</span>        </code></pre></figure>

    <p></p>
To pinpoint the main influencers in the knowledge graph, we employed betweenness centrality metrics. This approach enabled us to identify nodes that serve as crucial connectors facilitating information flow throughout the network. The initial step involves creating a graph using the NetworkX library:
<p></p>  

<p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s">'score'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.95</span><span class="p">][[</span><span class="s">'idx1'</span><span class="p">,</span> <span class="s">'idx2'</span><span class="p">]]</span>
<span class="n">edges</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s">'idx1'</span><span class="p">:</span> <span class="s">'source'</span><span class="p">,</span> <span class="s">'idx2'</span><span class="p">:</span> <span class="s">'target'</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>        </code></pre></figure>


<p></p>
Next, we determined the top 10 nodes with the highest betweenness centrality scores, highlighting the most influential connectors in the graph:
    <p></p>               

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">betweenness_rewired</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="n">top_rewired</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">betweenness_rewired</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span></code></pre></figure>

<p></p>



<h3>In Conclusion</h3>
<p></p>

In this post, we introduced a novel approach to better understand and analyze complex connections within networks by incorporating descriptive texts into graph structures. Traditional models often miss the subtle nuances in textual content that are crucial for revealing hidden linkages and intricate interactions.
<p></p>
Our method treats interactions as high-dimensional entities, transforming email exchange triplets into nodes for the next graph layer and applying a GNN Link Prediction model. This approach captures the complexity of relationships beyond simple pairwise interactions, providing a nuanced understanding of multifaceted connections. By including text-driven relationships, our model allows for deeper semantic analysis, uncovering the underlying meanings and contexts within communications.
<p></p>
Combining semantic and topological features, our approach bridges the gap between textual content and network structure, offering a comprehensive view of the network. Applying this method to the Enron network demonstrated its effectiveness in revealing hidden linkages and identifying key influencers, highlighting its broad applicability.
<p></p>
By focusing on both semantics and graph topology, and leveraging higher graph layers, our method shows potential for use in various fields, including social networks, bioinformatics, healthcare, and beyond. This work paves the way for future research to explore and exploit the intricate interplay between textual content and network structures, advancing the field of network analysis.


<p></p>    





<p></p>

<p></p>

<p></p>
<p></p>
</p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2024/05/25/slidingWindowGraph/" data-toggle="tooltip" data-placement="top" title="Sliding Window Graph in GNN Graph Classification">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2024/07/04/vectorsGNN/" data-toggle="tooltip" data-placement="top" title="Unlocking the Power of Pre-Final Vectors in GNN Graph Classification">Next Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="mailto:sparkling.dataocean@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Melenar 2024</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-114694347-1', 'auto');
  ga('send', 'pageview');

</script>



</body>

</html>
