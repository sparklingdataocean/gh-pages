<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Boutique consulting -- AI & Data Analytics.">

    <title>Sliding Window Graph in GNN Graph Classification - Sparkling Data Ocean</title>

    <link rel="canonical" href="http://localhost:4000/2024/05/25/slidingWindowGraph/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Sparkling Data Ocean" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114694347-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-114694347-1');
    </script>

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Sparkling Data Ocean</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
				
                <li>
                    <a href="/about/">About</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/pageVec20.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Sliding Window Graph in GNN Graph Classification</h1>
                    
                    <h2 class="subheading">GNN Graph Classification for Time Series: A New Perspective on Climate Change Analysis</h2>
                    
                    <span class="meta">Posted by Melenar on May 25, 2024</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<h2>Graph AI for Time-Series Change Detection</h2>
<p>
  Sliding time series graphs transform long, noisy signals into a sequence of short, structured snapshots,
  each captured as its own graph. By analyzing these snapshots with graph-based AI, we can pinpoint when a
  system shifts from normal to unusual behavior, highlight emerging regimes, and separate stable periods
  from early warning signals. Instead of a single summary label for an entire asset, customer base, or
  region, this approach shows <em>when</em> and <em>where</em> change is happening, enabling faster, more
  targeted decisions.
</p>

<h2>Conference &amp; Publication</h2>
<p>
  This work was presented at <strong>ICMLT 2024</strong> in Oslo, Norway, on
  <strong>24‚Äì25 May 2024</strong>, as the paper
  <em>‚ÄúGNN Graph Classification for Time Series: A New Perspective on Climate Change Analysis‚Äù</em>,
  doi:
  <a href="https://doi.org/10.1145/3674029.3674059" target="_blank" rel="noopener">
    10.1145/3674029.3674059
  </a>.
</p>
<p>
  In that presentation, we combined and compared two GNN-based methods for time series climate
  analysis. Our earlier work,
  <a href="http://sparklingdataocean.com/2023/02/11/cityTempGNNgraphs/" target="_blank" rel="noopener">
    ‚ÄúGNN Graph Classification for Climate Change Patterns‚Äù
  </a>,
  introduced the <strong>city-graph method</strong>, which captures static temporal snapshots to sort
  cities into ‚Äústable‚Äù and ‚Äúunstable‚Äù climate categories. The ICMLT paper extended this with a
  new <strong>sliding window graph method</strong>, which breaks time series into overlapping
  segments, turns each segment into a graph, and uses GNN graph classification to reveal how
  short-term climate behavior shifts over time.
</p>

<h2> Time Series Meets GNN Graph Classification</h2>
<p>The use of Graph Neural Networks (GNNs) in time series analysis represents a rising field of study, particularly in the context of GNN Graph Classification, a technique traditionally applied in disciplines such as biology and chemistry. Our research repurposes GNN Graph Classification for the analysis of time series climate data, focusing on two distinct methodologies: the city-graph method, which effectively captures static temporal snapshots, and the sliding window graph method, adept at tracking dynamic temporal changes. This innovative application of GNN Graph Classification within time series data enables the uncovering of nuanced data trends.</p>
<p></p>
<p>We demonstrate how GNNs can construct meaningful graphs from time series data, showcasing their versatility across different analytical contexts. A key finding is GNNs‚Äô adeptness at adapting to changes in graph structure, which significantly improves outlier detection. This enhances our understanding of climate patterns and suggests broader applications of GNN Graph Classification in analyzing complex data systems beyond traditional time series analysis. Our research seeks to fill a gap in current studies by providing an examination of GNNs in climate change analysis, highlighting the potential of these methods in capturing and interpreting intricate data trends.</p>

<h3> Introduction</h3>
<p></p>

<p>In 2012, deep learning and knowledge graphs took a big leap forward in data analysis and machine learning. AlexNet, a new type of Convolutional Neural Network (CNN) for image classification, showed much better results than older methods. Around the same time, Google introduced knowledge graphs, which improved how data is integrated and managed.</p>
<p></p>
<p>However, CNNs struggled with graph-structured data, and graph techniques lacked deep learning‚Äôs ability to recognize patterns. This changed with the arrival of Graph Neural Networks (GNNs). GNNs combined deep learning with graph data processing, making it easier to analyze graph-structured data.</p>
<p></p>
<p>GNN models are designed specifically for graph data. They use geometric relationships and combine node features with graph structure. This makes them very useful for tasks like node classification, link prediction, and graph classification. GNN Graph Classification models, which have been used in areas like chemistry and medicine, classify entire graphs based on their structure and features.</p>
<p></p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow1.jpg" alt="Post Sample Image" width="777" />
</a></p>
<p></p>
<p></p>
<p>In 2021, the ‚ÄúGeometric Deep Learning‚Äù paper was written when Convolutional Neural Networks (CNNs) were the dominant models in the deep learning landscape. If the paper were written in 2023-2024, Large Language Models (LLMs) would undoubtedly be considered the leading technology. The field of deep learning is rapidly evolving, and it remains to be seen what new advancements and models will emerge as the ‚Äúbiggest animals‚Äù in the next 2-3 years.</p>
<p></p>

<p>In this study, we expand on our previous research using Graph Neural Network (GNN) models to analyze climate data. Our earlier method categorized climate time series data into ‚Äòstable‚Äô and ‚Äòunstable‚Äô to identify unusual patterns in climate change.</p>
<p></p>
<p>Now, we introduce the sliding window graph method, which breaks down time series data into overlapping sections to capture specific time-related features. This approach creates graphs from these sections, offering a new perspective on short-term climate changes.</p>
<p></p>
<p>Our previous study used a city-graph method, where nodes represent city-year combinations with daily temperature vectors as features. The new sliding window method compares identical dates across different cities and years, helping us understand global climate trends.</p>
<p></p>
<p>Our research aims to explore the potential of GNN graph classification in identifying and interpreting global climate dynamics, providing valuable insights into seasonal changes and long-term shifts in climate.</p>

<p></p>

<h3>Methods</h3>
<p></p>
<h4>Graph Construction Methods</h4>
<p></p>
<p>In our study, we explore two different methods for constructing graphs from climate data: the City-Graph Method and the Sliding Window Method.</p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow2.jpg" alt="Post Sample Image" width="678" />
</a></p>
<p></p>
<p></p>
<p>City-Graph Method:</p>
<p></p>
<ul>
        <li>Creating graphs where nodes represent city-year pairs.</li>
        <li>Features are daily temperature vectors for each city-year.</li>
        <li>Edges are established based on cosine similarities between the temperature vectors of different city-years.</li>
        <li>Categorizes city graphs into 'stable' or 'unstable' climates based on their temperature patterns over time.</li>
</ul>
<p></p>
<p>Sliding Window Method:</p>
<p></p>
<ul>
        <li>Constructing graphs by breaking down time series data into overlapping sections.</li>
        <li>Nodes represent data points within a sliding window, with features reflecting their values.</li>
        <li>Edges connect sequential points to maintain the temporal sequence.</li>
        <li>Labels are assigned to capture patterns within the time series.</li>
</ul>

<p></p>

<p></p>
<h4>Common Pipeline</h4>
<p></p>
<p>While the graph construction methods differ, both follow a common pipeline for GNN Graph Classification:</p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow3.jpg" alt="Post Sample Image" width="678" />
</a></p>
<p></p>

<ul>
        <li><strong>Data Input:</strong> daily temperature data for 1000 populous cities over 40 years.</li>
        <li><strong>Climate Trends</strong> as 'stable' or 'unstable'.</li>
        <li><strong>Graph Construction:</strong>
            <ul>
                <li>City-Graph Method.</li>
                <li>Sliding Window Method.</li>
            </ul>
        </li>
        <li><strong>Virtual Nodes:</strong> to act as central hubs in small graphs, tuning the models for better accuracy..</li>

        <li><strong>GNN Model Application:</strong> use GNN model to classify graphs based on patterns.</li>
</ul>

<p></p>

<p></p>

<h4>Methodology for Sliding Window Graph Construction</h4>

<p>Our approach uses Graph Neural Networks (GNNs) combined with a sliding window technique to analyze time series data. Here‚Äôs an overview of the process:</p>

<h5>Data to Graph Transformation</h5>
<p>We segment time series data into smaller graphs using a sliding window, which captures local temporal patterns. Each time segment forms a unique graph.</p>

<h5>Graph Creation</h5>
<p>In these graphs, nodes represent data points within the window, with features reflecting their values. Edges connect these sequential points to maintain the temporal order.</p>

<h5>Crucial Parameters</h5>
<p>The window size (W) and overlap (shift size S) are important as they determine how the data is segmented and analyzed. Edge definitions within the graphs are tailored to the specifics of the time series data, helping to detect patterns.</p>

<h5>Node Calculation</h5>
<p>For a dataset with N data points, we apply a sliding window of size W with a shift of S to create nodes. The number of nodes, N<sub>nodes</sub>, is calculated as:
    <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
            <msub>
                <mi>N</mi>
                <mi>nodes</mi>
            </msub>
            <mo>=</mo>
            <mrow>
                <mo>&lfloor;</mo>
                <mfrac>
                    <mrow>
                        <mi>N</mi>
                        <mo>-</mo>
                        <mi>W</mi>
                    </mrow>
                    <mi>S</mi>
                </mfrac>
                <mo>&rfloor;</mo>
            </mrow>
            <mo>+</mo>
            <mn>1</mn>
        </mrow>
    </math></p>

<h5>Graph Calculation</h5>
<p>With the nodes determined, we construct graphs, each comprising G nodes, with a shift of S<sub>g</sub> between successive graphs. The number of graphs, N<sub>graphs</sub>, is calculated by:
    <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
            <msub>
                <mi>N</mi>
                <mi>graphs</mi>
            </msub>
            <mo>=</mo>
            <mrow>
                <mo>&lfloor;</mo>
                <mfrac>
                    <mrow>
                        <msub>
                            <mi>N</mi>
                            <mi>nodes</mi>
                        </msub>
                        <mo>-</mo>
                        <mi>G</mi>
                    </mrow>
                    <msub>
                        <mi>S</mi>
                        <mi>g</mi>
                    </msub>
                </mfrac>
                <mo>&rfloor;</mo>
            </mrow>
            <mo>+</mo>
            <mn>1</mn>
        </mrow>
    </math></p>

<p>This method allows us to analyze time series data effectively by capturing both local and global patterns, providing valuable insights into temporal dynamics.</p>
<p></p>
<h4>Model Training</h4>
<p></p>

<p>Our methodology involves processing both city-centric and sliding window graphs. We start by generating cosine similarity matrices from time series data, which are then converted into graph adjacency matrices. This process includes creating edges for vector pairs with cosine values above a set threshold and adding a virtual node to ensure network connectivity, a critical step for preparing the graph structure.</p>
<p></p>
<p>For graph classification tasks, we use the GCNConv model from the PyTorch Geometric Library. This model excels in feature extraction through its convolutional operations, taking into account edges, node attributes, and graph labels for comprehensive graph analysis. The approach concludes with the training phase of the GNN model, applying these techniques to both types of graphs for robust classification.</p>
<p></p>

<p></p>
<h3>Experiments Overview</h3>
<p></p>
<h4>Data Source: Climate Data</h4>

<p></p>
<p>For this study, we utilized climate data from Kaggle, specifically the dataset titled
<i><a href="https://www.kaggle.com/hansukyang/temperature-history-of-1000-cities-1980-to-2020">‚ÄúTemperature History of 1000 Cities 1980 to 2020‚Äù</a></i>.
This dataset provides average daily temperature data from 1980 to 2020 for the 1000 most populous cities in the world.
This comprehensive dataset served as the foundation for both the city-centric and sliding window graph methods employed in our analysis.</p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow4.jpg" alt="Post Sample Image" width="678" />
</a></p>
<p></p>
<p>The bar chart shows city frequency by latitude. Most cities are between 20 and 60 degrees in the Northern Hemisphere. There are fewer cities around the equator and even fewer in the Southern Hemisphere.</p>

<p></p>
<h4>Sliding Window Graph GNN Graph Classification</h4>
<p></p>
<p>Using a 40-year dataset of daily temperatures from 1000 cities, our study evaluates GNN‚Äôs effectiveness in identifying global climate patterns. We focus on data from January 1st to the start of each month, providing insights into climate consistency, seasonal changes, and long-term shifts.</p>
<p></p>
<h5>Sliding Window Analysis for Global Climate Data.</h5>
<p></p>
<p>In our global climate data analysis, we use the sliding window graph method on a dataset with 40 years of daily temperatures from 1000 cities. This approach segments the data into graphs, each defined by a 30-day window (ùëä = 30) with a 7-day shift (ùëÜ = 7), effectively capturing local climate dynamics. This results in 1624 small graphs, allowing us to analyze short-term climate variations and trends.</p>
<p></p>
<p>Our accuracy metrics provide insights into the stability and variability of global climate patterns. High accuracy suggests predictable seasonal trends, while lower accuracy indicates irregular climate patterns or shifts. The sliding window graph method allows us to thoroughly evaluate the model‚Äôs ability to identify complex patterns in large climate datasets.</p>
<p></p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow5.jpg" alt="Post Sample Image" width="678" />
</a></p>
<p></p>
<p>When examining closely spaced months, such as January 1st to February 1st and January 1st to December 1st, the GNN model‚Äôs accuracy around 0.5 suggests difficulty in identifying distinct climate patterns. This low accuracy points to potential variability and unpredictability in global weather patterns during these periods, highlighting the complex dynamics of weather.</p>
<p></p>
<p>For periods between January and months like March, April, or October, the model achieves accuracy metrics averaging around 0.7 to 0.8, indicating moderate success in capturing climatic patterns. This is likely due to the model‚Äôs proficiency in identifying consistent seasonal transitions over these extended timeframes.</p>
<p></p>
<p>The highest accuracy metrics, ranging from 0.94 to 0.99, are observed for months other than January, such as May, June, July, August, and September. These results reflect the model‚Äôs exceptional performance in predicting climate patterns during these months, particularly in the stable summer months. This suggests that the GNN model excels in recognizing and adapting to distinctive climatic patterns, resulting in highly accurate predictions.</p>
<p></p>
<h5>Sliding Window Analysis for Stable and Unstable Climate Data.</h5>
<p></p>
<p>For classification, we split our graph dataset into ‚Äòstable‚Äô and ‚Äòunstable‚Äô groups based on average cosine similarities between consecutive years. This method segmented the global dataset into stable and unstable categories for our sliding window analysis. Using 20,000 city-year combinations, we set a window size of 30 (ùëä = 30) and a shift size of 6 (ùëÜ = 6), facilitating precise computations for both stable and unstable datasets. Each graph contains 30 nodes (ùê∫ = 30), with a shift of 4 (ùëÜùëî = 4) between successive graphs, resulting in a total of 1648 small graphs.</p>
<p></p>
<p>In our study, GNN graph classification for stable climate cities starts with moderate accuracy in February, significantly improves by May reaching a peak of 100%, and maintains high accuracy through the summer months, only to dip in October with a slight recovery in November. In contrast, unstable climate cities start with near-random accuracy in February, improve steadily, peak in August, and then decline sharply, returning to early-year levels by December. This indicates the model‚Äôs varying adaptability to stable and unstable climate patterns throughout the year.</p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow6.jpg" alt="Post Sample Image" width="678" />
</a></p>
<p></p>
<p></p>
<p>Analysis starting from January 1 shows that the model‚Äôs performance is influenced by the time of year. Unstable climates see low accuracies in the early and late parts of the year, suggesting limited learning during these periods. Conversely, stable climates exhibit significant improvements in accuracy during spring and summer, indicating effective data integration. However, the model‚Äôs performance overall is subject to fluctuations, peaking in the summer months before declining towards the end of the year, highlighting the challenges in generalizing across seasonal variations in climate data.</p>
<p></p>

<p></p>
<h4>Code Details</h4>
<p></p>
<p>The <code class="language-plaintext highlighter-rouge">create_segments_df</code> function segments a specified column from a DataFrame into fixed-size windows. For each segment, it adds context such as the start date, row index, and column label. The function then combines these segments into a new DataFrame. This is useful for time series analysis or preparing data for machine learning models.</p>
<p></p>
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">create_segments_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span><span class="n">columnLabel</span><span class="p">):</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">column_name</span><span class="p">]].</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">.</span><span class="n">T</span>  <span class="c1"># Transpose to get the segment as a row
</span>        <span class="n">segment</span><span class="p">[</span><span class="sh">'</span><span class="s">start_date</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">date</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">segment</span><span class="p">[</span><span class="sh">'</span><span class="s">rowIndex</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">rowIndex</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">segment</span><span class="p">[</span><span class="sh">'</span><span class="s">theColumn</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">column_name</span>
        <span class="n">segment</span><span class="p">[</span><span class="sh">'</span><span class="s">columnLabel</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">columnLabel</span>
        <span class="n">segments</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p></p>

<p></p>
<p>The <code class="language-plaintext highlighter-rouge">group_segments</code> function takes a DataFrame of segments and groups them into larger segments based on specified sizes and shifts. It adds a group index to each group and combines them into a new DataFrame. This is useful for aggregating data over larger windows, essential for graph-based models or detailed data analysis.</p>
<p></p>

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">group_segments</span><span class="p">(</span><span class="n">segments_df</span><span class="p">,</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">group_shift</span><span class="p">):</span>
    <span class="n">grouped_segments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">group_index</span> <span class="o">=</span> <span class="mi">0</span>  
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">segments_df</span><span class="p">)</span> <span class="o">-</span> <span class="n">group_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">group_shift</span><span class="p">):</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">segments_df</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">group_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">group</span><span class="p">[</span><span class="sh">'</span><span class="s">graphIndex</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_index</span>  <span class="c1"># Assign group index
</span>        <span class="n">grouped_segments</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">group_index</span> <span class="o">+=</span> <span class="mi">1</span>  
    <span class="k">return</span> <span class="n">pd</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="n">grouped_segments</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p></p>
<p>Take columns <code class="language-plaintext highlighter-rouge">col1</code> and <code class="language-plaintext highlighter-rouge">col2</code> from a dataset, fill NaN values in with their mean values and scale these columns using MinMaxScaler.</p>
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="nc">MinMaxScaler</span><span class="p">()</span>
<span class="n">fx_data</span><span class="o">=</span><span class="n">df</span>
<span class="k">if</span> <span class="n">col1</span> <span class="ow">in</span> <span class="n">fx_data</span><span class="p">.</span><span class="n">columns</span><span class="p">:</span>
    <span class="n">fx_data</span><span class="p">[</span><span class="n">col1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx_data</span><span class="p">[</span><span class="n">col1</span><span class="p">].</span><span class="nf">fillna</span><span class="p">(</span><span class="n">fx_data</span><span class="p">[</span><span class="n">col1</span><span class="p">].</span><span class="nf">mean</span><span class="p">())</span>
    <span class="n">fx_data</span><span class="p">[</span><span class="n">col1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">fx_data</span><span class="p">[[</span><span class="n">col1</span><span class="p">]])</span>
<span class="k">if</span> <span class="n">col2</span> <span class="ow">in</span> <span class="n">fx_data</span><span class="p">.</span><span class="n">columns</span><span class="p">:</span>
    <span class="n">fx_data</span><span class="p">[</span><span class="n">col2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx_data</span><span class="p">[</span><span class="n">col2</span><span class="p">].</span><span class="nf">fillna</span><span class="p">(</span><span class="n">fx_data</span><span class="p">[</span><span class="n">col2</span><span class="p">].</span><span class="nf">mean</span><span class="p">())</span>
    <span class="n">fx_data</span><span class="p">[</span><span class="n">col2</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">fx_data</span><span class="p">[[</span><span class="n">col2</span><span class="p">]])</span></code></pre></figure>

<p></p>
<p></p>

<p>The code creates segments from two columns (<code>col1</code> and <code>col2</code>) of a dataset using the <code>create_segments_df</code> function, assigns node indices to each segment, and then groups these segments with the <code>group_segments</code> function. It combines the grouped segments into a final dataset, assigning a unique <span style="color: blue;">datasetIdx</span> to each. Finally, it generates metadata for each dataset index and merges it with the segment data to form <span style="color: blue;">graphList</span>.</p>

<p></p>

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">columnLabel</span><span class="o">=</span><span class="mi">0</span>
<span class="n">segments1</span> <span class="o">=</span> <span class="nf">create_segments_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">columnLabel</span><span class="p">)</span>
<span class="n">columnLabel</span><span class="o">=</span><span class="mi">1</span>
<span class="n">segments2</span> <span class="o">=</span> <span class="nf">create_segments_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">columnLabel</span><span class="p">)</span>
<span class="n">segments1</span><span class="p">[</span><span class="sh">'</span><span class="s">nodeIndex</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="n">segments1</span><span class="p">.</span><span class="n">index</span>
<span class="n">segments2</span><span class="p">[</span><span class="sh">'</span><span class="s">nodeIndex</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="n">segments2</span><span class="p">.</span><span class="n">index</span>
<span class="n">grouped_segments1</span> <span class="o">=</span> <span class="nf">group_segments</span><span class="p">(</span><span class="n">segments1</span><span class="p">,</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">group_shift</span><span class="p">)</span>
<span class="n">grouped_segments2</span> <span class="o">=</span> <span class="nf">group_segments</span><span class="p">(</span><span class="n">segments2</span><span class="p">,</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">group_shift</span><span class="p">)</span>
<span class="n">dataSet</span><span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">concat</span><span class="p">([</span><span class="n">grouped_segments1</span><span class="p">,</span> <span class="n">grouped_segments2</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">dataSet</span><span class="p">[</span><span class="sh">'</span><span class="s">datasetIdx</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="n">dataSet</span><span class="p">[</span><span class="sh">'</span><span class="s">columnLabel</span><span class="sh">'</span><span class="p">]</span><span class="o">*</span><span class="n">graphMax</span><span class="o">+</span><span class="n">dataSet</span><span class="p">[</span><span class="sh">'</span><span class="s">graphIndex</span><span class="sh">'</span><span class="p">]</span>
<span class="n">dataSubset</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[[</span><span class="sh">'</span><span class="s">datasetIdx</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">graphIndex</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">columnLabel</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">theColumn</span><span class="sh">'</span><span class="p">]].</span><span class="nf">drop_duplicates</span><span class="p">()</span>
<span class="n">graphMeta</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">.</span><span class="nf">groupby</span><span class="p">([</span> <span class="sh">'</span><span class="s">datasetIdx</span><span class="sh">'</span><span class="p">])[</span><span class="sh">'</span><span class="s">start_date</span><span class="sh">'</span><span class="p">].</span><span class="nf">agg</span><span class="p">([</span><span class="sh">'</span><span class="s">min</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">max</span><span class="sh">'</span><span class="p">])</span>
<span class="n">graphList</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">dataSubset</span><span class="p">,</span> <span class="n">graphMeta</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="sh">'</span><span class="s">datasetIdx</span><span class="sh">'</span><span class="p">)</span></code></pre></figure>

<p></p>

<p>Continuation of coding is described in our previous study, <a href="http://sparklingdataocean.com/2023/02/11/cityTempGNNgraphs/">‚ÄúGNN Graph Classification for Climate Change Patterns: Graph Neural Network (GNN) Graph Classification - A Novel Method for Analyzing Time Series Data‚Äù</a>. This current work continues the same coding methodology for both city graphs and sliding window graphs.</p>

<p></p>
<h4>Comparison of GNN Graph Classification Methods.</h4>
<p></p>
<p>In this research, we evaluated two distinct GNN Graph Classification techniques for analyzing climate data: the city-graph and the sliding window graph methods. The city-graph method assigns a node to each city-year pair, connecting them based on the cosine similarity of their temperature profiles, making it particularly suited for analyzing long-term climate trends. In contrast, the sliding window technique divides time series data into overlapping segments to form graphs, adeptly identifying short-term climate variations.</p>
<p></p>
<p>Both techniques were applied to the same dataset to compare their effectiveness in categorizing cities by climate stability. We found that the city-graph method more accurately discerned long-term climate stability, whereas the sliding window approach excelled in detecting short-term climate changes. Therefore, the choice of method depends on the specific objectives of the analysis: the city-graph is preferable for examining extended trends, while the sliding window method is ideal for investigating immediate climatic shifts.</p>
<p></p>

<p></p>

<p></p>

<p></p>
<h3>In Conclusion</h3>
<p></p>

<p>GNN graph classification has shown its strength in mapping complex relationships within graph-based datasets, making it a versatile tool in fields ranging from molecular dynamics to social network analysis. This versatility extends to climate data analysis, where it aids in identifying stable versus unstable climate patterns across cities by evaluating average cosine similarities of yearly temperature fluctuations. The addition of the sliding window graph approach further refines our study, enabling the model to continuously integrate new data and offer a detailed view of changing climate patterns. This technique is adept at capturing the dynamic nature of climate data, allowing for a more nuanced analysis of temporal trends and making it particularly suitable for managing the variable nature of climate data. This method‚Äôs ability to prioritize recent data over older information is crucial for adapting to the fast-paced changes characteristic of climate patterns.</p>
<p></p>
<p>In this study, we have leveraged GNN graph classification to address the complex challenge of analyzing climate patterns across different geographic locales, underscoring the method‚Äôs adaptability and broad applicability. Our research aimed explicitly at harnessing the potential of GNNs to distinguish between stable and unstable climate conditions in cities worldwide, using average cosine similarities of annual temperature variations as a novel classification metric. By integrating the sliding window graph approach, we have enhanced our model‚Äôs ability to dynamically assimilate and refresh data, offering a granular perspective on the fluctuating climate patterns and their implications over time.</p>
<p></p>
<p></p>
<p><a href="#">
    <img src="/img/slidingWindow7.jpg" alt="Post Sample Image" width="678" />
</a></p>
<p></p>
<p>This investigation has demonstrated that while equatorial cities exhibit consistency in climate stability, higher latitude cities experience more pronounced fluctuations. Remarkably, our analysis also brought to light certain anomalies, such as Mediterranean cities with unexpectedly consistent climates and cities in China and Mexico with notable climate variability. These findings highlight the critical importance of considering local geographical and climatic factors in climate studies and underscore the nuanced capabilities of GNN models in detecting subtle climate dynamics.</p>
<p></p>
<p>Ultimately, our study reinforces the utility of GNN graph classification, especially with the incorporation of the sliding window approach, as a potent tool for dissecting and understanding climate data. This method does not merely augment the predictive accuracy of our models but significantly bolsters their adaptability to ongoing climate changes, offering a richer comprehension of the complex interplay of factors influencing global climate trends. As such, GNN graph classification emerges as an indispensable instrument in the ongoing efforts to tackle the multifaceted challenges posed by global climate change, paving the way for more informed and effective climate resilience strategies.</p>

<p></p>

<p></p>

<p></p>
<p></p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/11/23/hiddenTriangles/" data-toggle="tooltip" data-placement="top" title="Uncovering Hidden Triangles">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2024/06/21/knowledgeGraphEmail/" data-toggle="tooltip" data-placement="top" title="Multi-Layer Graph Analysis for Text-Driven Relationships Using GNN Link Prediction">Next Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="mailto:sparkling.dataocean@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Graph AI Studio 2026</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-114694347-1', 'auto');
  ga('send', 'pageview');

</script>



</body>

</html>
