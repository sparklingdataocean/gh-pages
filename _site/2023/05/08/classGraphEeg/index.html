<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Spark for Big Data Analytics.">

    <title>GNN Graph Classification for EEG Pattern Analysis - Sparkling Data Ocean</title>

    <link rel="canonical" href="http://localhost:4000/2023/05/08/classGraphEeg/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Sparkling Data Ocean" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114694347-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-114694347-1');
    </script>

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Sparkling Data Ocean</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
				
                <li>
                    <a href="/about/">About</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/pageEgg1l.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>GNN Graph Classification for EEG Pattern Analysis</h1>
                    
                    <h2 class="subheading">Graph Neural Network for time-series analysis</h2>
                    
                    <span class="meta">Posted by Melenar on May 8, 2023</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<p><h3>GNN for pattern discovery in time series data</h3>

In one of our previous posts <i><a href="http://sparklingdataocean.com/2020/08/19/brainGraphEeg/">
"EEG Patterns by Deep Learning and Graph Mining"</a></i> we studied how to use CNN image classification to distinguish between Alcoholic person behavior and behavior of person from Control group based on EEG data. This study was presented
in <i><a href="
https://www.dexa.org/previous/dexa2021/protime2021.html">"The 1st International Workshop on Time Ordered Data (ProTime2021)"</a></i>
of DEXA 2021 conference and it was published in <i><a href="https://link.springer.com/chapter/10.1007/978-3-030-87101-7_19">"Time Series Pattern Discovery by Deep Learning and Graph Mining"</a></i> paper.
</p>
<p>
That study found that using the Gramian Angular Field (GAF) image transformation technique for time series data improved the accuracy of CNN image classification models compared to using raw plot pictures. By transforming the time series vectors into GAF images, the data was represented in a different embedded space that captured different aspects of the data compared to raw plots of the EEG data. This suggests that GAF image transformation is a useful technique for improving the accuracy of image classification models for time series data.
</p>
<p>
The study utilized a combination of advanced deep learning CNN image classification models and traditional graph mining techniques for time series pattern discovery. For image classification, the time series vectors were transformed into GAF images, and for graph mining, the study created graphs based on pairwise cosine similarities between the time series data points. To analyze these graphs, traditional graph mining techniques such as community detection and graph visualization were applied. This hybrid approach enabled the study to capture and analyze different aspects of the time series data, leading to a more comprehensive understanding of the patterns present in the data.
</p>
<p>
In this study we will explore how Graph Neural Network (GNN) graph classification models can be applied to classify time series data based on the underlying graph structure.

</p>
<p>

<p><h3>Introduction</h3>

<p><h4>Why GNN Graph Classification?</h4>
</p><p>
Graph mining is the process of extracting useful information from graphs. Traditional graph-based algorithms such as graph clustering, community detection, and centrality analysis have been used for this purpose. However, these methods have limitations in terms of their ability to learn complex representations and features from graph-structured data.
</p><p>
Graph Neural Networks (GNN) were developed to address these limitations. GNNs enable end-to-end learning of representations and features from graph data, allowing deep learning algorithms to process and learn from graph data. By modeling the relationships between the nodes and edges in a graph, GNNs can capture the underlying structure and dynamics of the graph. This makes them a powerful tool for analyzing and processing complex graph-structured data in various domains, including social networks, biological systems, and recommendation systems.
</p><p>

GNN models allow for deep learning on graph-structured data by modeling entity relationships and capturing graph structures and dynamics. They can be used for tasks such as node classification, link prediction, and graph classification. Node classification models predict the label or category of a node based on its local and global neighborhood structure. Link prediction models predict whether a link should exist between two nodes based on node attributes and graph structure. Graph classification models classify entire graphs into different categories based on their structure and attributes.

</p><p>

</p><p>
GNN graph classification models are developed to classify small graphs and in practice they are commonly used in the fields of chemistry and medicine. For example, chemical molecular structures can be represented as graphs, with atoms as nodes, chemical bonds as edges, and graphs labeled by categories.
</p><p>

In this post we will experiment with time series graph classification from healthcare domains and GNN graph classification models will be applied to electroencephalography (EEG) signal data by modeling the brain activity as a graph. Methods presented on this post can also be applied to time series data in various fields such as engineering, healthcare, and finance. The input data for the GNN graph classification models is a set of small labeled graphs, where each graph represents a group of nodes corresponding to time series and edges representing some measures of similarities or correlations between them.
</p><p>

</p><p>


</p><p>

</p><p>

<p><h4>Why EEG Data?</h4>
</p><p>

EEG tools studying human behaviors are well described in Bryn Farnsworth's blog
<i><a href="
https://imotions.com/blog/eeg/">"EEG (Electroencephalography): The Complete Pocket Guide"</a></i>. There are several reasons why EEG is an exceptional tool for studying the neurocognitive processes:
</p><p>
<ul>
<li>EEG has very high time resolution and captures cognitive processes in the time frame in which cognition occurs.
</li>
<li>EEG directly measures neural activity.</li>
<li>EEG is inexpensive, lightweight, and portable.</li>
<li>EEG data is publically available: we found this dataset in Kaggle.com</li>
</ul>
</p><p>
The study will use the same approach as the one described above, where EEG signal data is modeled as a graph to represent brain activity. The nodes in the graph will represent brain regions or electrode locations, and edges will represent functional or structural connections between them. The raw data for the experiments will come from the kaggle.com EEG dataset 'EEG-Alcohol', which was part of a large study on EEG correlates of genetic predisposition to alcoholism.
</p><p>
The study aims to use GNN graph classification models to predict alcoholism, where a single graph corresponds to one brain reaction on a trial. Time series graphs will be created for each trial using electrode positions as nodes, EEG channel signals as node features, and graph edges as pairs of vectors with cosine similarities above certain thresholds. The EEG graph classification models will be used to determine whether a person is from the alcoholic or control group based on their trial reactions, which can potentially help in early detection and treatment of alcoholism.

</p><p>


</p><p>


</p><p>



</p><p>
<p><h3>Related Work</h3>
</p><p>
<p><h4>Machine Learning as EEG Analysis</h4>
</p><p>
Electroencephalography (EEG) signals are complex and require extensive training and advanced signal processing techniques for proper interpretation. Deep learning has shown promise in making sense of EEG signals by learning feature representations from raw data. In the

meta-data analysis paper <i><a href="
https://arxiv.org/pdf/1901.05498.pdf">"Deep learning-based electroencephalography analysis: a systematic review"</a></i>

the authors conduct a meta-analysis of EEG deep learning and compare it to traditional EEG processing methods to determine which deep learning approaches work well for EEG data analysis and which do not.
</p><p>

In a previous study, EEG channel data was transformed into graphs based on pairwise cosine similarities. These graphs were analyzed using connected components and visualization techniques. Traditional graph mining methods were used to find explicit EEG channel patterns by transforming time series into vectors, constructing graphs based on cosine similarity, and identifying patterns using connected components.


</p><p>

</p><p>
<p></p>
<p></p>
<a href="#">
    <img src="/img/dataSource5.jpg" alt="Post Sample Image" width="500" />
</a>
<p></p>


</p>
<p></p><p>

</p><p>
<p><h3>Methods</h3>

In GNN graph classification for EEG data, separate graphs will be created for each brain-trial. Indicators of the alcohol or control group of corresponding person will be used as labels for the graphs. The electrode positions will be used as nodes, and channel signals will be used as node features. Graph edges will be defined as pairs of vectors with cosine similarities higher than thresholds. For the GNN graph classification model, a GCNConv (Graph Convolutional Network Convolution) model from PyTorch Geometric Library (PyG) will be used.
<p></p><p>
In this section we will describe data processing and model training methods is the following order:
<ul>
<li>
Cosine similarity matrix functions.
</li><li>
Process of transforming cosine similarity matrices to graphs.
</li><li>
Process of training GNN graph classification model.

</li>
</ul>

</p><p>

<h4>Cosine Similarity Function</h4>

</p><p>
For cosine similarities we used the following functions:

<p></p>
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">torch</span>
<span class="k">def</span> <span class="nf">pytorch_cos_sim</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">cos_sim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cos_sim</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">a_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">functional</span><span class="p">.</span><span class="nf">normalize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b_norm</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">functional</span><span class="p">.</span><span class="nf">normalize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">mm</span><span class="p">(</span><span class="n">a_norm</span><span class="p">,</span> <span class="n">b_norm</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></code></pre></figure>


<p></p>

<p></p>
<h4>Cosine Similarity Matrices to Graphs</h4>
</p><p>
Next, for each brain-trial we will calculate cosine similarity matrices and transform them into graphs by taking only vector pairs with cosine similarities higher than a threshold.
</p><p>

For each brain-trial graph we will add a virtual node to transform disconnected graphs into single connected components. This process makes it is easier for GNN graph classification models to process and analyze the relationships between nodes.

</p><p>


</p><p>
<h4>Train the Model</h4>
</p><p>
The GNN graph classification model is designed to process input graph data, including both the edges and node features, and is trained on graph-level labels. In this case, the input data structure consists of the following components:
</p><p>
<ul>
<li>
Edges: The graph adjacency matrix represents the relationships between nodes in the graph. For instance, it could represent the correlations between daily temperature vectors over different years.
</li><li>
Nodes with embedded features: The node features, such as the average values of the consecutive yearly sequences, would be embedded into the nodes to provide additional information to the GNN graph classification model.
</li><li>
Labels on graph level: The labels, such as alcohol or control group, are assigned to the graph as a whole, and the GNN graph classification model uses these graph-level labels to make predictions about the alcohol or non-alcohol patterns.
</li></ul>

</p><p>
This study uses a GCNConv model from PyTorch Geometric Library as a GNN graph classification model. The GCNConv model is a type of graph convolutional network that applies convolutional operations to extract meaningful features from the input graph data (edges, node features, and the graph-level labels). The code for the model is taken from a PyG tutorial.
</p><p>
<p></p>

</p><p>
<p><h3>Experiments</h3>
</p><p>
<h4>EEG Data Source</h4>
<p></p>
<p></p>
For this post we used EEG dataset that we found in kaggle.com website: <i><a href="https://www.kaggle.com/nnair25/Alcoholics">'EEG-Alcohol' Kaggle dataset.</a></i> This dataset came from a large study of examining EEG correlates of genetic predisposition to alcoholism. We will classify EEG channel time series data to alcoholic and control person's EEG channels. Note: there are some data quality problems in this dataset.
<p></p>
<a href="#">
    <img src="/img/picEEG1a.jpg" alt="Post Sample Image" width="600" />
</a>
<p></p>
Amount of subjects in each group is 8. The 64 electrodes were placed on subject's scalps to measure the electrical activity of the brain. The response values were sampled at 256 Hz (3.9-msec epoch) for 1 second.
Each subject was exposed to either a single stimulus (S1) or to two stimuli (S1 and S2) which were pictures of objects chosen from the 1980 Snodgrass and Vanderwart picture set. When two stimuli were shown, they were presented in either a matched condition where S1 was identical to S2 or in a non-matched condition where S1 differed from S2. The total number of person-trial combination was 61.

</p>

<h4>Transform Raw Data to EEG Channel Time Series</h4>
<p></p>
Kaggle EEG dataset was well analyzed in
<i><a href="https://www.kaggle.com/ruslankl/eeg-data-analysis"> 'EEG Data Analysis: Alcoholic vs Control Groups' </a></i>
Kaggle notebook by Ruslan Klymentiev. We used his code for some parts of our data preparation. Here is raw data:
<p></p>
<p></p>
<a href="#">
    <img src="/img/dataSource1.jpg" alt="Post Sample Image" width="700" />
</a>
<p></p>
Python code to transform raw data to EEG channel time series data :
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">EEG_data</span><span class="p">[</span><span class="sh">'</span><span class="s">rn</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="n">EEG_data</span><span class="p">.</span><span class="nf">groupby</span><span class="p">([</span><span class="sh">'</span><span class="s">sensor position</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">trial number</span><span class="sh">'</span><span class="p">,</span>
   <span class="sh">'</span><span class="s">subject identifier</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">matching condition</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]).</span><span class="nf">cumcount</span><span class="p">()</span>
<span class="n">EEG_TS</span><span class="o">=</span><span class="n">EEG_data</span><span class="p">.</span><span class="nf">pivot_table</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">trial number</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">sensor position</span><span class="sh">'</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">subject identifier</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">matching condition</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">channel</span><span class="sh">'</span><span class="p">],</span>
    <span class="n">columns</span><span class="o">=</span><span class="sh">'</span><span class="s">rn</span><span class="sh">'</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="sh">'</span><span class="s">sensor value</span><span class="sh">'</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="sh">'</span><span class="s">first</span><span class="sh">'</span><span class="p">).</span><span class="nf">reset_index</span><span class="p">()</span>
<span class="n">EEG_TS</span><span class="p">.</span><span class="nf">tail</span><span class="p">()</span></code></pre></figure>

<p></p>
EEG channels - time series data:
<p></p>

<p></p>
<a href="#">
    <img src="/img/dataSource2.jpg" alt="Post Sample Image" width="700" />
</a>
<p>
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">EEG_TS</span><span class="o">=</span><span class="n">EEG_TS</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">trial number</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">trial</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">sensor position</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">,</span>
                                <span class="sh">'</span><span class="s">subject identifier</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">matching condition</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">match</span><span class="sh">'</span><span class="p">,</span>
                                <span class="sh">'</span><span class="s">Unnamed: 0</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">})</span></code></pre></figure>

<p></p>
Calculate EEG positions
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">positions</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">EEG_TS</span><span class="p">[</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">].</span><span class="nf">unique</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">])</span>
<span class="n">positions</span><span class="p">.</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">positions</span><span class="p">[</span><span class="sh">'</span><span class="s">positionIdx</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="n">positions</span><span class="p">.</span><span class="n">index</span>
<span class="n">inputData</span><span class="o">=</span><span class="n">EEG_TS</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="sh">'</span><span class="s">inner</span><span class="sh">'</span><span class="p">)</span>
<span class="n">inputData</span><span class="p">.</span><span class="nf">tail</span><span class="p">()</span></code></pre></figure>

<p></p>
Define 61 groups for small graphs:
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">inputData</span> <span class="o">=</span> <span class="n">inputData</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">([</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">trial</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">])</span>
<span class="n">inputData</span><span class="p">[</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputData</span><span class="p">[</span><span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">].</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">inputData</span><span class="p">.</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">inputData</span><span class="p">[</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputData</span><span class="p">.</span><span class="n">index</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="n">inputData</span><span class="p">[</span><span class="sh">'</span><span class="s">group</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="n">inputData</span><span class="p">[</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">]</span><span class="o">//</span><span class="mi">61</span></code></pre></figure>

<p></p>

Calculate cosine similarity matrix by brain-trial groups:
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">IMG</span><span class="o">=</span><span class="sh">'</span><span class="s">/content/drive/My Drive/EEG/groupCos/</span><span class="sh">'</span>

<span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">61</span><span class="p">):</span>
  <span class="n">data1</span><span class="o">=</span><span class="n">inputData</span><span class="p">[(</span><span class="n">inputData</span><span class="p">[</span><span class="sh">'</span><span class="s">group</span><span class="sh">'</span><span class="p">]</span><span class="o">==</span><span class="n">group</span><span class="p">)]</span>
  <span class="n">values1</span><span class="o">=</span><span class="n">data1</span><span class="p">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">262</span><span class="p">]</span>
  <span class="n">fXValues1</span><span class="o">=</span> <span class="n">values1</span><span class="p">.</span><span class="nf">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">values</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
  <span class="n">fXValuesPT1</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">fXValues1</span><span class="p">)</span>
  <span class="n">cosine_scores1</span> <span class="o">=</span> <span class="nf">pytorch_cos_sim</span><span class="p">(</span><span class="n">fXValuesPT1</span><span class="p">,</span> <span class="n">fXValuesPT1</span><span class="p">)</span>
  <span class="n">cosPairs1</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">61</span><span class="p">):</span>
    <span class="n">position1</span><span class="o">=</span><span class="n">data1</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">61</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
        <span class="n">score</span><span class="o">=</span><span class="n">cosine_scores1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>  
        <span class="n">position2</span><span class="o">=</span><span class="n">data1</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">]</span>
        <span class="n">combo</span><span class="o">=</span><span class="nf">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="sh">'</span><span class="s">~</span><span class="sh">'</span><span class="o">+</span><span class="n">position1</span><span class="o">+</span><span class="sh">'</span><span class="s">~</span><span class="sh">'</span><span class="o">+</span><span class="n">position2</span>
        <span class="n">cosPairs1</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">'</span><span class="s">combo</span><span class="sh">'</span><span class="p">:</span><span class="n">combo</span><span class="p">,</span> <span class="sh">'</span><span class="s">left</span><span class="sh">'</span><span class="p">:</span><span class="n">position1</span><span class="p">,</span> <span class="sh">'</span><span class="s">right</span><span class="sh">'</span><span class="p">:</span><span class="n">position2</span><span class="p">,</span> <span class="sh">'</span><span class="s">cos</span><span class="sh">'</span><span class="p">:</span> <span class="n">score</span><span class="p">})</span>
  <span class="n">dfCosPairs1</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">cosPairs1</span><span class="p">)</span>
  <span class="n">path</span><span class="o">=</span><span class="n">IMG</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span><span class="o">+</span><span class="sh">"</span><span class="s">scores.csv</span><span class="sh">"</span>
  <span class="n">dfCosPairs1</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span></code></pre></figure>

<p></p>

<p></p>

<p></p>


</p>


<p></p>

<p></p>
<h4>Prepare Input Data for GNN Graph Classification Model</h4>
<p></p>

In GNN graph classification, the input to the model is typically a set of small graphs that represent entities in the dataset. These graphs are composed of nodes and edges, where nodes represent entities, and edges represent the relationships between them. Both nodes and edges may have associated features that describe the attributes of the entity or relationship, respectively. These features can be used by the GNN model to learn the patterns and relationships in the data, and classify or predict labels for the graphs. By considering the structure of the data as a graph, GNNs can be particularly effective in capturing the complex relationships and dependencies between entities, making them a useful tool for a wide range of applications.
<p></p>
As input for GNN graph classification for EEG data we created separate graphs for all 61 person-trial combinations. As graph labels we used indicators of alcohol or control group of corresponding person. For graph nodes as node features we used electrode positions as nodes and EEG channel signals. As graph edges, for each graph we calculated cosine similarity matrices and selected pairs of nodes with cosine similarities higher that thresholds.
<p></p>
In this study, one of the challenges was to define thresholds for creating input graphs for GNN graph classification. As there were only 61 person-trial graphs available, this number was not sufficient for training a GNN graph classification model. To overcome this challenge, additional input graphs were created by varying the threshold values randomly within a predefined range (0.75, 0.95). This approach helped to augment the input dataset and improve the performance of the GNN graph classification model.
<p></p>

The following code prepares input data for GNN graph classification model:
<p></p>

<ul>
<li>Transform cosine similarity matries to graph adjacency matrices based on treasholds
</li><li>For each brain-trial graph add a virtual node to transform disconnected graphs into single connected components.
</li><li>Transform data to PyTorch Geometric data format
</li>
</ul>
</p><p>


<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">random</span>
<span class="kn">from</span> <span class="n">torch_geometric.loader</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="n">datasetModel</span><span class="o">=</span><span class="nf">list</span><span class="p">()</span>
<span class="n">datasetTest</span><span class="o">=</span><span class="nf">list</span><span class="p">()</span>
<span class="n">cosPairsUnion</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">()</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">17</span><span class="p">):</span>
  <span class="n">cosPairsRange</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">()</span>
  <span class="n">cos</span><span class="o">=</span><span class="nf">round</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span> <span class="mi">20</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">61</span><span class="p">):</span>
    <span class="n">name</span><span class="o">=</span><span class="n">groupAtrbts</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">group</span><span class="p">,</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">trial</span><span class="o">=</span><span class="n">groupAtrbts</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">group</span><span class="p">,</span> <span class="sh">'</span><span class="s">trial</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">label</span><span class="o">=</span><span class="n">groupAtrbts</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">group</span><span class="p">,</span> <span class="sh">'</span><span class="s">type</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">data1</span><span class="o">=</span><span class="n">subData</span><span class="p">[(</span><span class="n">subData</span><span class="p">[</span><span class="sh">'</span><span class="s">group</span><span class="sh">'</span><span class="p">]</span><span class="o">==</span><span class="n">group</span><span class="p">)]</span>
    <span class="n">values1</span><span class="o">=</span><span class="n">data1</span><span class="p">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">:</span><span class="mi">262</span><span class="p">]</span>
    <span class="n">fXValues1</span><span class="o">=</span> <span class="n">values1</span><span class="p">.</span><span class="nf">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">values</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">fXValuesPT1</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">fXValues1</span><span class="p">)</span>
    <span class="n">fXValuesPT1avg</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">fXValuesPT1</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">).</span><span class="nf">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">fXValuesPT1union</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">fXValuesPT1</span><span class="p">,</span><span class="n">fXValuesPT1avg</span><span class="p">),</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cosPairs1</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">61</span><span class="p">):</span>
      <span class="n">position1</span><span class="o">=</span><span class="sh">'</span><span class="s">XX</span><span class="sh">'</span>
      <span class="n">position2</span><span class="o">=</span><span class="n">positionList</span><span class="p">[(</span><span class="n">positionList</span><span class="p">[</span><span class="sh">'</span><span class="s">positionIdx</span><span class="sh">'</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">)][</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">]</span>
      <span class="n">cosPairs1</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">'</span><span class="s">round</span><span class="sh">'</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="sh">'</span><span class="s">cos</span><span class="sh">'</span><span class="p">:</span><span class="n">cos</span><span class="p">,</span>
          <span class="sh">'</span><span class="s">group</span><span class="sh">'</span><span class="p">:</span><span class="n">group</span><span class="p">,</span> <span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">:</span><span class="n">label</span><span class="p">,</span> <span class="sh">'</span><span class="s">k1</span><span class="sh">'</span><span class="p">:</span><span class="mi">61</span><span class="p">,</span><span class="sh">'</span><span class="s">k2</span><span class="sh">'</span><span class="p">:</span><span class="n">i</span><span class="p">,</span>
          <span class="sh">'</span><span class="s">pos1</span><span class="sh">'</span><span class="p">:</span><span class="n">position1</span><span class="p">,</span> <span class="sh">'</span><span class="s">pos2</span><span class="sh">'</span><span class="p">:</span><span class="n">position2</span><span class="p">,</span><span class="sh">'</span><span class="s">score</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.99</span><span class="p">})</span>
    <span class="n">edge1</span><span class="o">=</span><span class="n">edges</span><span class="p">[(</span><span class="n">edges</span><span class="p">[</span><span class="sh">'</span><span class="s">group</span><span class="sh">'</span><span class="p">]</span><span class="o">==</span><span class="n">group</span><span class="p">)]</span>
    <span class="n">edge1</span><span class="p">.</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">edge1</span><span class="p">[</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge1</span><span class="p">.</span><span class="n">index</span>
    <span class="n">size</span><span class="o">=</span><span class="n">edge1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
      <span class="n">score2</span><span class="o">=</span><span class="n">edge1</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="sh">'</span><span class="s">cos</span><span class="sh">'</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">score2</span><span class="o">&gt;</span><span class="n">cos</span><span class="p">:</span>
        <span class="n">position1</span><span class="o">=</span><span class="n">edge1</span><span class="p">[</span><span class="sh">'</span><span class="s">col1</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">position2</span><span class="o">=</span><span class="n">edge1</span><span class="p">[</span><span class="sh">'</span><span class="s">col2</span><span class="sh">'</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">k1</span><span class="o">=</span> <span class="n">positionList</span><span class="p">[</span><span class="sh">'</span><span class="s">positionIdx</span><span class="sh">'</span><span class="p">].</span><span class="n">index</span><span class="p">[</span><span class="n">positionList</span><span class="p">[</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">position1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">k2</span><span class="o">=</span> <span class="n">positionList</span><span class="p">[</span><span class="sh">'</span><span class="s">positionIdx</span><span class="sh">'</span><span class="p">].</span><span class="n">index</span><span class="p">[</span><span class="n">positionList</span><span class="p">[</span><span class="sh">'</span><span class="s">position</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">position2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cosPairs1</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">'</span><span class="s">round</span><span class="sh">'</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="sh">'</span><span class="s">cos</span><span class="sh">'</span><span class="p">:</span><span class="n">cos</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">group</span><span class="sh">'</span><span class="p">:</span><span class="n">group</span><span class="p">,</span> <span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">:</span><span class="n">label</span><span class="p">,</span> <span class="sh">'</span><span class="s">k1</span><span class="sh">'</span><span class="p">:</span><span class="n">k1</span><span class="p">,</span><span class="sh">'</span><span class="s">k2</span><span class="sh">'</span><span class="p">:</span><span class="n">k2</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">pos1</span><span class="sh">'</span><span class="p">:</span><span class="n">position1</span><span class="p">,</span> <span class="sh">'</span><span class="s">pos2</span><span class="sh">'</span><span class="p">:</span><span class="n">position2</span><span class="p">,</span><span class="sh">'</span><span class="s">score</span><span class="sh">'</span><span class="p">:</span> <span class="n">score2</span><span class="p">})</span>
    <span class="n">dfCosPairs1</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">cosPairs1</span><span class="p">)</span>
    <span class="n">edge2</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">dfCosPairs1</span><span class="p">[[</span><span class="sh">'</span><span class="s">k1</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">k2</span><span class="sh">'</span><span class="p">]].</span><span class="n">T</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">dataset1</span> <span class="o">=</span> <span class="nc">Data</span><span class="p">(</span><span class="n">edge_index</span><span class="o">=</span><span class="n">edge2</span><span class="p">)</span>
    <span class="n">dataset1</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">label</span><span class="p">])</span>
    <span class="n">dataset1</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="n">fXValuesPT1union</span>
    <span class="n">datasetModel</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">dataset1</span><span class="p">)</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">datasetModel</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
    <span class="n">cosPairsRange</span> <span class="o">=</span> <span class="n">cosPairsRange</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">dfCosPairs1</span><span class="p">])</span>
    <span class="n">cosPairsUnion</span> <span class="o">=</span> <span class="n">cosPairsUnion</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">dfCosPairs1</span><span class="p">])</span></code></pre></figure>


<p></p>

<p></p>


<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">modelSize</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span class="n">modelSize</span>
<span class="mi">1037</span></code></pre></figure>


<p></p>
<p><h4>Training GNN Graph Classification Model</h4>
<p></p>
Randomly split input data to training and tesing:
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">random</span>
<span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
<span class="n">percent</span> <span class="o">=</span> <span class="mf">0.15</span>
<span class="n">sample_size</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">modelSize</span> <span class="o">*</span> <span class="n">percent</span><span class="p">)</span>
<span class="n">train_size</span><span class="o">=</span><span class="nf">int</span><span class="p">(</span><span class="n">modelSize</span><span class="o">-</span><span class="n">sample_size</span><span class="p">)</span>
<span class="n">test_dataset</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">sample_size</span><span class="p">)</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">train_size</span><span class="p">)</span><span class="n">e</span><span class="p">)</span>
<span class="n">test_loader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></code></pre></figure>

<p></p>


<p></p>
For this study we used the code provided by PyTorch Geometric as tutorial on GCNConv graph classification models - we just slightly tuned it for our data:
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">torch.nn</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">import</span> <span class="n">torch.nn.functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="n">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">GCNConv</span>
<span class="kn">from</span> <span class="n">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">global_mean_pool</span>

<span class="k">class</span> <span class="nc">GCN</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">GCN</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="n">hidden_channels</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="n">hidden_channels</span><span class="p">,</span> <span class="n">hidden_channels</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lin</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">hidden_channels</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="c1"># 1. Obtain node embeddings
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">relu</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">relu</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">conv3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">)</span>

        <span class="c1"># 2. Readout layer
</span>        <span class="n">x</span> <span class="o">=</span> <span class="nf">global_mean_pool</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span>  <span class="c1"># [batch_size, hidden_channels]
</span>
        <span class="c1"># 3. Apply a final classifier
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">lin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">GCN</span><span class="p">(</span><span class="n">hidden_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span></code></pre></figure>

<p></p>
</p>
<h4>Train the Model</h4>
<p></p>


<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">IPython.display</span> <span class="kn">import</span> <span class="n">Javascript</span>
<span class="nf">display</span><span class="p">(</span><span class="nc">Javascript</span><span class="p">(</span><span class="sh">'''</span><span class="s">google.colab.output.setIframeHeight(0, true, {maxHeight: 300})</span><span class="sh">'''</span><span class="p">))</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">GCN</span><span class="p">(</span><span class="n">hidden_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">CrossEntropyLoss</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">train</span><span class="p">():</span>
    <span class="n">model</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">train_loader</span><span class="p">:</span>  <span class="c1"># Iterate in batches over the training dataset.
</span>         <span class="n">out</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nf">float</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">batch</span><span class="p">)</span>  <span class="c1"># Perform a single forward pass.
</span>         <span class="n">loss</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Compute the loss.
</span>         <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>  <span class="c1"># Derive gradients.
</span>         <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>  <span class="c1"># Update parameters based on gradients.
</span>         <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>  <span class="c1"># Clear gradients.
</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">loader</span><span class="p">):</span>
     <span class="n">model</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
     <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
     <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">loader</span><span class="p">:</span>  <span class="c1"># Iterate in batches over the training/test dataset.
</span>         <span class="n">out</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nf">float</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">batch</span><span class="p">)</span>  
         <span class="n">pred</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Use the class with highest probability.
</span>         <span class="n">correct</span> <span class="o">+=</span> <span class="nf">int</span><span class="p">((</span><span class="n">pred</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">y</span><span class="p">).</span><span class="nf">sum</span><span class="p">())</span>  <span class="c1"># Check against ground-truth labels.
</span>     <span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">loader</span><span class="p">.</span><span class="n">dataset</span><span class="p">)</span>  <span class="c1"># Derive ratio of correct predictions.
</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="nf">train</span><span class="p">()</span>
    <span class="n">train_acc</span> <span class="o">=</span> <span class="nf">test</span><span class="p">(</span><span class="n">train_loader</span><span class="p">)</span>
    <span class="n">test_acc</span> <span class="o">=</span> <span class="nf">test</span><span class="p">(</span><span class="n">test_loader</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="mi">03</span><span class="n">d</span><span class="si">}</span><span class="s">, Train Acc: </span><span class="si">{</span><span class="n">train_acc</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">, Test Acc: </span><span class="si">{</span><span class="n">test_acc</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span></code></pre></figure>

<p></p>

<p></p>
<a href="#">
    <img src="/img/epics1.jpg" alt="Post Sample Image" width="777" />
</a>
<p></p>
To estimate the model results we used the same model accuracy metrics as in the PyG tutorial: training data accuracy was about 98.4 percents and testing data accuracy was about 98.1 percents. Reasons for the fluctations in accuracy can be explained by the rather small dataset (only 155 test graphs)
<p></p>
<p></p>
</p>
<h4>Interpret EEG Model Results</h4>

<p></p>
To interpret model results we calculated the softmax probabilities for each class output by the model. The softmax probabilities represent the model's confidence in its prediction for each class.

In the output of the graph classification model we have 17 outliers with the model's predictions not equal to the input labels.
<p></p>


<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">modelSize</span>
<span class="mi">1037</span></code></pre></figure>


<p></p>

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">softmax</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Softmax</span><span class="p">(</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">graph1</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">modelSize</span><span class="p">):</span>
  <span class="n">label</span><span class="o">=</span><span class="n">datasetTest</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
  <span class="n">out</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">datasetTest</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">x</span><span class="p">.</span><span class="nf">float</span><span class="p">(),</span> <span class="n">datasetTest</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">datasetTest</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">batch</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">out</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
  <span class="n">pred</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">detach</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
  <span class="n">graph1</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">:</span><span class="n">g</span><span class="p">,</span>
                 <span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">:</span><span class="n">label</span><span class="p">,</span><span class="sh">'</span><span class="s">pred</span><span class="sh">'</span><span class="p">:</span><span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                 <span class="sh">'</span><span class="s">prob0</span><span class="sh">'</span><span class="p">:</span><span class="nf">round</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span><span class="sh">'</span><span class="s">prob1</span><span class="sh">'</span><span class="p">:</span><span class="nf">round</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">)})</span></code></pre></figure>

<p></p>

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">graph2df</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">graph1</span><span class="p">)</span>

<span class="nf">len</span><span class="p">(</span><span class="n">graph2_df</span><span class="p">[</span><span class="n">graph2_df</span><span class="p">[</span><span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">]</span><span class="o">==</span><span class="n">graph2_df</span><span class="p">[</span><span class="sh">'</span><span class="s">pred</span><span class="sh">'</span><span class="p">]])</span>
<span class="mi">1020</span>

<span class="nf">len</span><span class="p">(</span><span class="n">graph2_df</span><span class="p">[</span><span class="n">graph2_df</span><span class="p">[</span><span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">]</span><span class="o">!=</span><span class="n">graph2_df</span><span class="p">[</span><span class="sh">'</span><span class="s">pred</span><span class="sh">'</span><span class="p">]])</span>
<span class="mi">17</span></code></pre></figure>

<p></p>

<p></p>
Here is detail information about these outliers:  

<p></p>

<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">graphDF</span><span class="p">[</span><span class="n">graphDF</span><span class="p">[</span><span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">]</span><span class="o">!=</span><span class="n">graphDF</span><span class="p">[</span><span class="sh">'</span><span class="s">pred</span><span class="sh">'</span><span class="p">]].</span><span class="nf">sort_values</span><span class="p">(</span><span class="sh">'</span><span class="s">prob0</span><span class="sh">'</span><span class="p">).</span><span class="nf">head</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span></code></pre></figure>

<p></p>
<p></p>
<a href="#">
    <img src="/img/resultsEEG1.jpg" alt="Post Sample Image" width="543" />
</a>
<p></p>
Our observations:
</p><p>
<ul>
<li>Probabilities of incorrectly predicted graph classification labels is close to 0.5 (between 0.45 and 0.55), which means that the model is very uncertain about these predictions.
</li>
<li>Type of stimulus in all outlier graphs is "single stimulus".
</li>
<li>
All outlier graphs belong to the same person (records have the same name, but different trials). These graphs marked as persons from Control group but they were predicted as persons from Alchogol group.
</li>
</ul>
</p><p>
Most of graph classifiction model results with low confidence also are related to "single stimulus" patters:
<p></p>
<p></p>
<p></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">graphDF</span><span class="p">[</span><span class="sh">'</span><span class="s">diff</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span><span class="nf">abs</span><span class="p">(</span><span class="n">graphDF</span><span class="p">[</span><span class="sh">'</span><span class="s">prob1</span><span class="sh">'</span><span class="p">]</span><span class="o">-</span><span class="n">graphDF</span><span class="p">[</span><span class="sh">'</span><span class="s">prob0</span><span class="sh">'</span><span class="p">])</span>
<span class="n">graphDF</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="sh">'</span><span class="s">diff</span><span class="sh">'</span><span class="p">).</span><span class="nf">head</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span></code></pre></figure>

<p></p>
<p></p>
<a href="#">
    <img src="/img/resultsEEG2.jpg" alt="Post Sample Image" width="589" />
</a>
<p></p>
<p></p>

This corresponds with the results of our previous study about EEG signal classification:
trials with "single stimulus" patters had lower confidence on CNN time series classification compared to trials with "two stimuli, matched" and "two stimuli, non-matched" patterns.



 <p></p>
 <a href="#">
     <img src="/img/dataSource7.jpg" alt="Post Sample Image" width="444" />
 </a>
 <p></p>

More interesting, graph vizualiation examples show that trials with "single stimulus" patters have much lower differences between persons from Alcoholic and Control groups then trials with "two stimuli, matched" and "two stimuli, non-matched" patterns.

The results of a previous study showed that trials with "single stimulus" patterns had much lower differences between persons from the alcoholic and control groups compared to trials with "two stimuli, matched" and "two stimuli, non-matched" patterns. This suggests that "single stimulus" trials are not sufficient for accurately distinguishing between the two groups. Furthermore, graph visualization examples taken from the previous study demonstrated this difference in patterns between the different types of stimuli.

 <p></p>
 <a href="#">
     <img src="/img/dataSource5.jpg" alt="Post Sample Image" width="374" />
 </a>
 <p></p>

<p><h3>Conclusion</h3>

In conclusion, this study provides evidence that GNN graph classification models can effectively classify time series data represented as graphs in EEG data. The study found that these methods are capable of capturing the complex relationships between the nodes in the input graphs and use this information to accurately classify them.
<p></p>
For each person-trial we created separate graphs that were labeled according to whether the corresponding person belonged to the alcohol or control group. Graph nodes were represented by electrode positions and node features were represented by the EEG channel signals.
<p></p>
Cosine similarity matrices were used to define graph edges by selecting vector pairs with cosines above a threshold, and transforming them into graph adjacency matrices. To ensure disconnected graphs became single connected components, to each graph was also added a virtual node.

<p></p>
The study encountered a limitation in the amount of input graphs available for model training. To overcome this limit, random thresholds were used to create additional input graphs, which increased the amount of input data available for training and improved the accuracy of the predictions.

<p></p>



<p></p>

The study found that GNN graph classification models are highly effective in accurately classifying time series data by capturing the relationships between the data points and using this information to make accurate predictions. In particular, GNN graph classification models accurately classified EEG recordings as alcoholic or non-alcoholic person.

 <p></p>

 The study identified some interesting outliers where the GNN graph classification model had difficulty accurately predicting the results. Specifically, it found that the model struggled to accurately classify graphs with a "single stimulus" type of stimulus and "single stimulus" trials were not sufficient for accurately distinguishing between the control and alcohol groups in EEG recordings. This finding is consistent with the results of a previous study, which found that trials with "single stimulus" patterns had lower confidence in CNN time series classification compared to trials with "two stimuli, matched" and "two stimuli, non-matched" patterns.

 <p></p>


<p></p>
Future research could investigate the use of GNN graph classification methods for other types of time series data and explore ways to address the identified limitations of these models. Overall, we believe that GNN graph classification models have great potential for a variety of applications in fields such as healthcare, environmental monitoring, and finance. For example, stock prices can be modeled as time series data and GNN Graph classification algorithms can be used to classify groups of time series into different patterns, such as bullish or bearish trends, which can be used for predicting future prices.
<p></p>
We hope that our study will contribute to the development of more accurate and effective classification models for time series data domains.


</p><p>



</p><p>

<p><h3>Next Post - EEG analysis</h3>
In the next several posts we will continue building bridges between AI, graphs and neuroscience.</p>
</p></p></p></p></p></p></p></p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/02/11/cityTempGNNgraphs/" data-toggle="tooltip" data-placement="top" title="GNN Graph Classification for Climate Change Patterns">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2023/07/07/knowledgeGraph4NlpGnn2/" data-toggle="tooltip" data-placement="top" title="Exploring Document Comparison with GNN Graph Classification">Next Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="mailto:sparkling.dataocean@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Melenar 2024</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-114694347-1', 'auto');
  ga('send', 'pageview');

</script>



</body>

</html>
